(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{512:function(t,a,r){"use strict";r.r(a);var v=r(8),_=Object(v.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"多线程的基础"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多线程的基础"}},[t._v("#")]),t._v(" 多线程的基础")]),t._v(" "),r("h2",{attrs:{id:"什么是进程什么是线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是进程什么是线程"}},[t._v("#")]),t._v(" 什么是进程什么是线程")]),t._v(" "),r("ol",[r("li",[t._v("什么是线程\n"),r("ol",[r("li",[t._v("资源分配的基本单位（静态概念）")])])]),t._v(" "),r("li",[t._v("什么是进程\n"),r("ol",[r("li",[t._v("资源调度的基本单位（动态概念)")])])])]),t._v(" "),r("h2",{attrs:{id:"为什么要写多线程程序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#为什么要写多线程程序"}},[t._v("#")]),t._v(" 为什么要写多线程程序")]),t._v(" "),r("ol",[r("li",[t._v("为了压榨CPU，提高资源利用率")])]),t._v(" "),r("h2",{attrs:{id:"创建线程的四种方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建线程的四种方式"}},[t._v("#")]),t._v(" 创建线程的四种方式")]),t._v(" "),r("ol",[r("li",[t._v("继承Thread类 重写run方法")]),t._v(" "),r("li",[t._v("实现Runnable接口 重写run方法")]),t._v(" "),r("li",[t._v("实现Callable 接口 重写Call方法")]),t._v(" "),r("li",[t._v("使用线程池")])]),t._v(" "),r("h2",{attrs:{id:"常见的线程方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常见的线程方法"}},[t._v("#")]),t._v(" 常见的线程方法")]),t._v(" "),r("ol",[r("li",[t._v("sleep 休眠,当前线程暂停一段时间让给别的线程去运行 参数为休眠时间 时间到就会复活")]),t._v(" "),r("li",[t._v("yieid 就是当前线程正在执行的时候停止下来进入等待队列（就绪状态，CPU依然有可能把这个线程拿出来运行），回到等待队列里在系统的调度算法里头呢还是依然有可能把你刚回去的这个线程拿回来继续执行，当然，更大的可能性是把原来等待的那些拿出一个来执行，所以yield的意思是我让出一下CPU，后面你们能不能抢到那我不管")]),t._v(" "),r("li",[t._v("join 意思就是在自己当前线程加入你调用Join的线程（），本线程等待。等调用的线程运行完了，自己再去执行。t1和t2两个线程，在t1的某个点上调用了t2.join,它会跑到t2去运行，t1等待t2运行完毕继续t1运行（自己join自己没有意义）")])]),t._v(" "),r("h2",{attrs:{id:"java的6种线程状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#java的6种线程状态"}},[t._v("#")]),t._v(" JAVA的6种线程状态:")]),t._v(" "),r("ol",[r("li",[t._v("NEW ：                    线程刚刚创建，还没有启动")]),t._v(" "),r("li",[t._v("RUNNABLE ：         可运行状态，由线程调度器可以安排执行\n"),r("ul",[r("li",[t._v("包括READY和RUNNING两种细分状态")])])]),t._v(" "),r("li",[t._v("WAITING：              等待被唤醒")]),t._v(" "),r("li",[t._v("TIMED WAITING： 隔一段时间后自动唤醒")]),t._v(" "),r("li",[t._v("BLOCKED：            被阻塞，正在等待锁")]),t._v(" "),r("li",[t._v("TERMINATED：      线程结束")])]),t._v(" "),r("h2",{attrs:{id:"线程的打断-interrupt"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程的打断-interrupt"}},[t._v("#")]),t._v(" 线程的打断(interrupt):")]),t._v(" "),r("h4",{attrs:{id:"interrupt相关的三个方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interrupt相关的三个方法"}},[t._v("#")]),t._v(" interrupt相关的三个方法")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("interrupt() ：实例方法，设置线程中断标志（打扰一下，你该处理一下中断）")])]),t._v(" "),r("li",[r("p",[t._v("isInterrupted()：实例方法，有没有人打扰我？")])]),t._v(" "),r("li",[r("p",[t._v("interrupted()：静态方法，有没有人打扰我（当前线程）？复位！")])])]),t._v(" "),r("h4",{attrs:{id:"interrupt是否能中断正在竞争锁的线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interrupt是否能中断正在竞争锁的线程"}},[t._v("#")]),t._v(" interrupt是否能中断正在竞争锁的线程")]),t._v(" "),r("p",[t._v("​\tinterrupt()不能打断正在竞争锁的线程synchronized() 如果想打断正在竞争锁的线程，使用ReentrantLock的lockInterruptibly()")]),t._v(" "),r("h4",{attrs:{id:"interrupt和sleep-wait-join"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#interrupt和sleep-wait-join"}},[t._v("#")]),t._v(" interrupt和sleep() wait() join()")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("sleep()方法在睡眠的时候，不到时间是没有办法叫醒的，这个时候可以用interrupt设置标志位\n\n然后呢必须得catch InterruptedException来进行处理，决定继续睡或者是别的逻辑，（自动进行中断标志复位）\n")])])]),r("h2",{attrs:{id:"如何优雅的结束线程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何优雅的结束线程"}},[t._v("#")]),t._v(" 如何优雅的结束线程")]),t._v(" "),r("ol",[r("li",[t._v("自然结束（能自然结束就尽量自然结束）")]),t._v(" "),r("li",[t._v("stop() suspend() resume()(不推荐使用 因为会强制停止线程,造成数据一致性问题)")]),t._v(" "),r("li",[t._v("volatile标志\n"),r("ol",[r("li",[t._v("不适合某些场景（比如还没有同步的时候，线程做了阻塞操作，没有办法循环回去）")]),t._v(" "),r("li",[t._v("打断时间也不是特别精确，比如一个阻塞容器，容量为5的时候结束生产者，\n但是，由于volatile同步线程标志位的时间控制不是很精确，有可能生产者还继续生产一段儿时间")])])]),t._v(" "),r("li",[t._v("interrupt() and isInterrupted（比较优雅）")])]),t._v(" "),r("h2",{attrs:{id:"线程的可见性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程的可见性"}},[t._v("#")]),t._v(" 线程的可见性")]),t._v(" "),r("h3",{attrs:{id:"线程的可见性是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程的可见性是什么"}},[t._v("#")]),t._v(" 线程的可见性是什么")]),t._v(" "),r("p",[t._v("多线程提高效率，本地缓存数据，造成数据修改不可见")]),t._v(" "),r("h3",{attrs:{id:"如何保证线程的可见性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何保证线程的可见性"}},[t._v("#")]),t._v(" 如何保证线程的可见性")]),t._v(" "),r("p",[t._v("要想保证可见，要么触发同步指令，要么加上volatile，被修饰的内存，只要有修改，马上同步涉及到的每个线程")]),t._v(" "),r("h3",{attrs:{id:"缓存行对齐"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存行对齐"}},[t._v("#")]),t._v(" 缓存行对齐")]),t._v(" "),r("p",[t._v("缓存行64个字节是CPU同步的基本单位，缓存行隔离会比伪共享效率要高 Disruptor")]),t._v(" "),r("p",[t._v("JDK8引入了@sun.misc.Contended注解，来保证缓存行隔离效果,要使用此注解，必须去掉限制参数：-XX:-RestrictContended")]),t._v(" "),r("h2",{attrs:{id:"程序的有序性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#程序的有序性"}},[t._v("#")]),t._v(" 程序的有序性")]),t._v(" "),r("h3",{attrs:{id:"cpu的乱序执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cpu的乱序执行"}},[t._v("#")]),t._v(" CPU的乱序执行")]),t._v(" "),r("p",[t._v("程序的乱序执行是确实存在的,存在的原因是为了提高效率")]),t._v(" "),r("h3",{attrs:{id:"as-if-serial"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#as-if-serial"}},[t._v("#")]),t._v(" as-if-serial")]),t._v(" "),r("p",[t._v("单个线程，两条语句，未必是按顺序执行")]),t._v(" "),r("p",[t._v("单线程的重排序，必须保证最终一致性")]),t._v(" "),r("p",[t._v("as-if-serial：看上去像是序列化（单线程）")]),t._v(" "),r("p",[t._v("多线程会产生不希望看到的结果")]),t._v(" "),r("h3",{attrs:{id:"哪些指令可以互换顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#哪些指令可以互换顺序"}},[t._v("#")]),t._v(" 哪些指令可以互换顺序")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("程序次序规则：同一个线程内，按照代码出现的顺序，前面的代码先行于后面的代码，准确的说是控制流顺序，因为要考虑到分支和循环结构。")])]),t._v(" "),r("li",[r("p",[t._v("管程锁定规则：一个unlock操作先行发生于后面（时间上）对同一个锁的lock操作。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("volatile变量规则：对一个volatile变量的写操作先行发生于后面（时间上）对这个变量的读操作。")])])]),t._v(" "),r("li",[r("p",[t._v("线程启动规则：Thread的start( )方法先行发生于这个线程的每一个操作。")])]),t._v(" "),r("li",[r("p",[t._v("线程终止规则：线程的所有操作都先行于此线程的终止检测。可以通过Thread.join( )方法结束、Thread.isAlive( )的返回值等手段检测线程的终止。")])]),t._v(" "),r("li",[r("p",[t._v("线程中断规则：对线程interrupt( )方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt( )方法检测线程是否中断")])]),t._v(" "),r("li",[r("p",[t._v("对象终结规则：一个对象的初始化完成先行于发生它的finalize()方法的开始。")])]),t._v(" "),r("li",[r("p",[t._v("传递性：如果操作A先行于操作B，操作B先行于操作C，那么操作A先行于操作C")])])]),t._v(" "),r("h3",{attrs:{id:"使用内存屏障阻止乱序执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#使用内存屏障阻止乱序执行"}},[t._v("#")]),t._v(" 使用内存屏障阻止乱序执行")]),t._v(" "),r("p",[t._v("内存屏障是特殊指令：看到这种指令，前面的必须执行完，后面的才能执行")]),t._v(" "),r("p",[t._v("intel : lfence sfence mfence(CPU特有指令)")]),t._v(" "),r("h3",{attrs:{id:"jvm中的内存屏障"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm中的内存屏障"}},[t._v("#")]),t._v(" JVM中的内存屏障")]),t._v(" "),r("p",[t._v("所有实现JVM规范的虚拟机，必须实现四个屏障")]),t._v(" "),r("p",[t._v("LoadLoadBarrier : 两条读指令不能换")]),t._v(" "),r("p",[t._v("StoreStoreBarrier : 两条写指令不能交换")]),t._v(" "),r("p",[t._v("LoadStoreBarrier : 先写后读不能交换")]),t._v(" "),r("p",[t._v("StoreLoadBarrier : 先写后读不能交换")]),t._v(" "),r("h2",{attrs:{id:"线程的原子性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线程的原子性"}},[t._v("#")]),t._v(" 线程的原子性")]),t._v(" "),r("p",[t._v("原子性是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被"),r("a",{attrs:{href:"https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%AD&spm=1001.2101.3001.7020",target:"_blank",rel:"noopener noreferrer"}},[t._v("中断"),r("OutboundLink")],1),t._v("操作，要不执行完成，要不就不执行**。**原子性就是指该操作是不可再分的。")]),t._v(" "),r("h4",{attrs:{id:"如何保障线程的原子性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何保障线程的原子性"}},[t._v("#")]),t._v(" 如何保障线程的原子性")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("悲观的认为这个操作会被别的线程打断（悲观锁）synchronized（上一个小程序）")])]),t._v(" "),r("li",[r("p",[t._v("乐观的认为这个做不会被别的线程打断（乐观锁 自旋锁 无锁）cas操作")])])]),t._v(" "),r("h3",{attrs:{id:"什么样的语句-指令-具备原子性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么样的语句-指令-具备原子性"}},[t._v("#")]),t._v(" 什么样的语句（指令）具备原子性？")]),t._v(" "),r("p",[t._v("CPU级别汇编，需要查询汇编手册！")]),t._v(" "),r("p",[t._v("Java中的8大原子操作：")]),t._v(" "),r("ol",[r("li",[t._v("lock：主内存，标识变量为线程独占")]),t._v(" "),r("li",[t._v("unlock：主内存，解锁线程独占变量")]),t._v(" "),r("li",[t._v("read：主内存，读取内存到线程缓存（工作内存）")]),t._v(" "),r("li",[t._v("load：工作内存，read后的值放入线程本地变量副本")]),t._v(" "),r("li",[t._v("use：工作内存，传值给执行引擎")]),t._v(" "),r("li",[t._v("assign：工作内存，执行引擎结果赋值给线程本地变量")]),t._v(" "),r("li",[t._v("store：工作内存，存值到主内存给write备用")]),t._v(" "),r("li",[t._v("write：主内存，写变量值")])]),t._v(" "),r("h3",{attrs:{id:"jvm中的两种锁"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#jvm中的两种锁"}},[t._v("#")]),t._v(" JVM中的两种锁")]),t._v(" "),r("p",[t._v("重量级锁（经过操作系统的调度）synchronized早期都是这种锁（目前的实现中升级到最后也是这种锁）")]),t._v(" "),r("p",[t._v("轻量级锁（CAS的实现，不经过OS调度）(无锁 - 自旋锁 - 乐观锁)")])])}),[],!1,null,null,null);a.default=_.exports}}]);