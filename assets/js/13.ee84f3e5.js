(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{508:function(r,o,t){"use strict";t.r(o);var v=t(8),_=Object(v.a)({},(function(){var r=this,o=r.$createElement,t=r._self._c||o;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h3",{attrs:{id:"锁的四种状态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#锁的四种状态"}},[r._v("#")]),r._v(" 锁的四种状态")]),r._v(" "),t("ol",[t("li",[t("p",[r._v("无锁")]),r._v(" "),t("p",[r._v("在线程开始后四秒中内创建的普通对象,视为无锁对象")]),r._v(" "),t("p",[r._v("markWord  锁标识位为01 偏向锁状位为0")])]),r._v(" "),t("li",[t("p",[r._v("偏向锁")]),r._v(" "),t("p",[r._v("markword 上记录当前线程指针，下次同一个线程加锁的时候，不需要争用，只需要判断线程指针是否同一个，所以，偏向锁，偏向加锁的第一个线程 。")]),r._v(" "),t("p",[r._v("markWord  锁标识位为01 偏向锁状位为1")])]),r._v(" "),t("li",[t("p",[r._v("自旋锁")]),r._v(" "),t("p",[r._v("有争用 - 锁升级为轻量级锁 - 每个线程有自己的LockRecord在自己的线程栈上，用CAS去争用markword的LR的指针，指针指向哪个线程的LR，哪个线程就拥有锁")]),r._v(" "),t("p",[r._v("markWord 锁标识位为 00")])]),r._v(" "),t("li",[t("p",[r._v("重量级锁")]),r._v(" "),t("p",[r._v("自旋超过10次，升级为重量级锁 - 如果太多线程自旋 CPU消耗过大，不如升级为重量级锁，进入等待队列（不消耗CPU）-XX:PreBlockSpin")]),r._v(" "),t("p",[r._v("markWord 锁标识位为 10")])])]),r._v(" "),t("h3",{attrs:{id:"synchronized的锁升级过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#synchronized的锁升级过程"}},[r._v("#")]),r._v(" synchronized的锁升级过程")]),r._v(" "),t("p",[r._v("锁状态：\n　　当一个对象刚开始new出来时，该对象是无锁状态。此时偏向锁位为0，锁标志位01如果有线程竞争,撤销偏向锁，升级轻量级锁\n线程在自己的线程栈生成LockRecord，用CAS操作将markword设置为指向自己这个线程的LockRecord的指针，设置成功者得到锁\n　　如果竞争加剧：有线程超过10次自旋， -XX:PreBlockSpin，或者自旋线程数超过CPU核树的一半，升级重量级锁： 向操作系统升级资源，等待操作系统的调度，然后再映射会用户空间；")])])}),[],!1,null,null,null);o.default=_.exports}}]);