(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{513:function(a,s,v){"use strict";v.r(s);var _=v(8),t=Object(_.a)({},(function(){var a=this,s=a.$createElement,v=a._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h3",{attrs:{id:"类加载机制概念"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载机制概念"}},[a._v("#")]),a._v(" 类加载机制概念")]),a._v(" "),v("p",[a._v("JAVA虚拟机给描述类的内容从Class加载到内存的过程")]),a._v(" "),v("h3",{attrs:{id:"类加载过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[a._v("#")]),a._v(" 类加载过程")]),a._v(" "),v("h4",{attrs:{id:"装载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#装载"}},[a._v("#")]),a._v(" 装载")]),a._v(" "),v("p",[a._v("通过一个类的完全限定名获取定义此类的二进制字节流,将这个字节流所代表的静态存储结构转换成方法区的运行时数据结构,在Java堆中生成一个代表这个类的java.lang.Class对象,作为方法区中这些数据的访问入口.")]),a._v(" "),v("h4",{attrs:{id:"连接"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[a._v("#")]),a._v(" 连接")]),a._v(" "),v("h5",{attrs:{id:"_1-验证"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-验证"}},[a._v("#")]),a._v(" 1. 验证")]),a._v(" "),v("p",[a._v("验证主要是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求,并且还要求外面的信息不会危害虚拟机自身的安全,导\t致虚拟机的崩溃.")]),a._v(" "),v("p",[a._v("主要包含的验证方式有:")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("文件格式验证:")]),a._v(" "),v("p",[a._v("验证字符流是否符合Class文件格式的规范,并且能被当前版本的虚拟机处理,该验证的主要目的就是为了确保输入的流能正确的被JVM解析并存储于方法区内.")]),a._v(" "),v("p",[a._v("比如是否以16进制的cafebabe开头.")])]),a._v(" "),v("li",[v("p",[a._v("版本号是否正确元数据验证:")]),a._v(" "),v("p",[a._v("JAVA的语法校验,保证不存在不符合规定的语法出现比如继承的父类是否存在 父类是否被final修饰字节码验证进行数据流和控制流进行分析,确定程序语法是合法的,符合逻辑性的.对类的方法体进行校验分析,保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为.")]),a._v(" "),v("p",[a._v("比如 栈数据类型和操作码操作参数吻合,比如栈空间只有四个字节但是我们实际需要的超过了四个字节,那么这个时候字节码就是有问题的.")])])]),a._v(" "),v("h5",{attrs:{id:"_2-准备"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-准备"}},[a._v("#")]),a._v(" 2. 准备")]),a._v(" "),v("p",[a._v("为类的静态变量分配内存,并将其初始化为默认值,注意这里不包含用final修饰的静态变量,因为final在编译的时候就会分配,准备阶段会显\t式初始化,这里不会为实例变量分配初始化,类变量会分配在方法区中,而实例变量是会随着对象一起分配到Java堆中.")]),a._v(" "),v("p",[a._v("比如 public static int a = 1;这段代码 a在准备阶段过后的初始值是0,不是1,因为这时候只是开辟了内存空间,并没有运行Java代码.")]),a._v(" "),v("p",[a._v("特殊情况:")]),a._v(" "),v("p",[a._v("如果类的字段属性表中存在ConstantValue属性,那在准备阶段变量a就会被彻底初始化为ConstantValue属性所指向的值.")]),a._v(" "),v("p",[a._v("在实际的开发中只有同时被final和static修饰的属性才会有Constant Value属性,且限于基本类型和String.")]),a._v(" "),v("h5",{attrs:{id:"_3-解析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-解析"}},[a._v("#")]),a._v(" 3.解析")]),a._v(" "),v("p",[a._v("了解解析步骤前 我们需要先了解两个概念分别是:")]),a._v(" "),v("p",[a._v("符号引用:一组符号来描述目标,可以是任何字面量")]),a._v(" "),v("p",[a._v("直接引用:就是直接指向目标的指针")]),a._v(" "),v("p",[a._v("解析阶段就是虚拟机将常量池的符号引用替换为直接引用的一个过程.")]),a._v(" "),v("p",[a._v("解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。")]),a._v(" "),v("h4",{attrs:{id:"初始化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),v("p",[a._v("初始化阶段是执行类构造器()方法的过程。")]),a._v(" "),v("p",[a._v("JVM初始化步骤：")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("假如这个类还没有被加载和连接,则程序先加载并连接该类")])]),a._v(" "),v("li",[v("p",[a._v("加入该类的直接父类还没有被初始化,则先初始化直接父类")])]),a._v(" "),v("li",[v("p",[a._v("加入类中有初始化语句,则依次执行这些初始化语句")])])]),a._v(" "),v("h4",{attrs:{id:"使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[a._v("#")]),a._v(" 使用")]),a._v(" "),v("p",[a._v("调用new关键字获取到对象后的一系列操作")]),a._v(" "),v("h4",{attrs:{id:"卸载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[a._v("#")]),a._v(" 卸载")]),a._v(" "),v("p",[a._v("在类使用完之后，如果满足下面的情况，类就会被卸载")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("该类所有的实例都已经被回收")])]),a._v(" "),v("li",[v("p",[a._v("加载该类的ClassLoader已经被回收")])]),a._v(" "),v("li",[v("p",[a._v("该类对应的java.lang.Class对象没有任何地方被引用")])])]),a._v(" "),v("p",[a._v("如果上面三个条件全部满足,jvm就会在垃圾回收的时候对类进行卸载,类的卸载过程也就是在方法区中清空类的信息.")]),a._v(" "),v("h3",{attrs:{id:"类加载器classloader"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#类加载器classloader"}},[a._v("#")]),a._v(" 类加载器ClassLoader")]),a._v(" "),v("h4",{attrs:{id:"什么是类加载器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是类加载器"}},[a._v("#")]),a._v(" 什么是类加载器")]),a._v(" "),v("p",[a._v("负责读取Java字节代码,并转换成java.lang.Class类,的一个实例的代码模块,")]),a._v(" "),v("h4",{attrs:{id:"java中类加载器有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java中类加载器有哪些"}},[a._v("#")]),a._v(" Java中类加载器有哪些")]),a._v(" "),v("ol",[v("li",[a._v("引导类加载器(Bootstrap ClassLoader):这个类负责加载Java的核心库,开发者无法直接使用")]),a._v(" "),v("li",[a._v("拓展类加载器(Extendsion ClassLoader):这个类用来加载java的拓展库,开发者可以直接使用")]),a._v(" "),v("li",[a._v("应用程序类加载器(Application ClassLoader):一般我们编写的类都是通过这个类加载.")]),a._v(" "),v("li",[a._v("自定义类加载器(Custom ClassLoader):通过继承java.lang.ClassLoader自定义加载class,属于应用程序根据自身需要自定义的ClassLoader")])]),a._v(" "),v("h3",{attrs:{id:"双亲委派机制加载class的具体过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制加载class的具体过程"}},[a._v("#")]),a._v(" 双亲委派机制加载Class的具体过程")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("ClassLoader加载器先判断该Class是否已加载,如果以加载,则返回Class对象,如果没有则委派给父加载器")])]),a._v(" "),v("li",[v("p",[a._v("父加载器判断该Class是否已加载,如果以加载,则返回Class对象,如果没有则委派给祖加载器.")])]),a._v(" "),v("li",[v("p",[a._v("依此类推，直到始祖类加载器.")])]),a._v(" "),v("li",[v("p",[a._v("始祖加载器判断是否加载过该Class,如果以加载,则返回Class对象;如果没有则尝试从其对应的类路径下寻找Class文件字节码并载入.如果载入成功,则返回Class对象;如果载入失败则委托给子加载器")])]),a._v(" "),v("li",[v("p",[a._v("始祖类加载器的子加载器尝试从其对应的类路径下寻找class字节码文件并载入,如果载\n入成功，则返回Class对象；如果载入失败，则委托给始祖类加载器的孙类加载器.")])]),a._v(" "),v("li",[v("p",[a._v("依此类推，直到源ClassLoader.")])]),a._v(" "),v("li",[v("p",[a._v("源ClassLoader尝试从其对应的类路径下寻找class字节码文件并载入。如果载入成功，则\n返回Class对象；如果载入失败，源ClassLoader不会再委托其子类加载器，而是抛出异\n常.")])])]),a._v(" "),v("p",[a._v("双亲委派机制只是Java推荐的机制，并不是强制的机制.\n我们可以继承java.lang.ClassLoader类，实现自己的类加载器.")]),a._v(" "),v("p",[a._v("如果想保持双亲委派模型，就应该重写findClass(name)方法.")]),a._v(" "),v("p",[a._v("如果想破坏双亲委派模型，可以重写loadClass(name)方法。")])])}),[],!1,null,null,null);s.default=t.exports}}]);