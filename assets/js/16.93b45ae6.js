(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{511:function(_,v,a){"use strict";a.r(v);var t=a(8),r=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h3",{attrs:{id:"_1-事务是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-事务是什么"}},[_._v("#")]),_._v(" 1.事务是什么")]),_._v(" "),a("p",[_._v("事务是具备原子性,一致性,隔离性和持久性,简称 ACID")]),_._v(" "),a("p",[_._v("原子性:即一个操作或者多个操作,要么全部执行并且执行的过程不会被任何因素打断,要么就都不执行")]),_._v(" "),a("p",[_._v("一致性: 一致性代表的就是数据一致性,比如下单买了一个物品,就需要物品库存-1,订单表数据+1,此操作是不可分割的,不会出现中间状态")]),_._v(" "),a("p",[_._v("隔离性:指多个事务同时执行的时候不会互相干扰,事务之间相互独立,中间状态对外不可见")]),_._v(" "),a("p",[_._v("持久性: 一个事件处理结束结果会永远保存,不会被其他后来事件所影响")]),_._v(" "),a("h3",{attrs:{id:"_2-分布式事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-分布式事务"}},[_._v("#")]),_._v(" 2.分布式事务")]),_._v(" "),a("p",[_._v("分布式事务就是在分布式架构中实现的事务.比如服务A调用服务B,服务B出现意外,服务A数据跟着回滚.它其实是由多个本地事务组合而成")]),_._v(" "),a("h3",{attrs:{id:"_3-了解xa规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-了解xa规范"}},[_._v("#")]),_._v(" 3.了解XA规范")]),_._v(" "),a("p",[_._v("XA规范是X/Open 组织针对二阶段提交协议的实现做的规范。目前几乎所有的主流数据库都对XA规范提供了支持。")]),_._v(" "),a("p",[_._v("X/Open的组织定义了分布式事务的模型,这里面有几个角色,")]),_._v(" "),a("p",[_._v("AP: Application: 应用程序 , 就是我们的服务")]),_._v(" "),a("p",[_._v("TM: Transaction Manager: 事务管理器 ,就是一个第三方,通过第三方来进行事务的一个管理")]),_._v(" "),a("p",[_._v("RM: Resource Manager: 资源管理器,就是我们的数据库")]),_._v(" "),a("h3",{attrs:{id:"_4-分布式事务的六种解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-分布式事务的六种解决方案"}},[_._v("#")]),_._v(" 4.分布式事务的六种解决方案")]),_._v(" "),a("h4",{attrs:{id:"_1-2pc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2pc"}},[_._v("#")]),_._v(" 1. 2PC")]),_._v(" "),a("p",[_._v("2PC: Two-Phase Commit，即二阶段提交.二阶段提交就是将事务拆分为两个阶段来处理,第一阶段执行不提交返回给事务管理器一个Boolean值,只有都为yes才执行提交,否则执行回滚.")]),_._v(" "),a("p",[_._v("缺点:")]),_._v(" "),a("p",[_._v("同步阻塞 占用数据连接池阻塞 一直到整个事务执行完毕才会给资源释放掉")]),_._v(" "),a("p",[_._v("单点故障:TM挂了")]),_._v(" "),a("h4",{attrs:{id:"_2-3pc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-3pc"}},[_._v("#")]),_._v(" 2. 3PC")]),_._v(" "),a("p",[_._v("3PC: Three-Phase Commit，即三阶段提交.是2PC的改良版,将二阶段的提交事务请求一分为二优化成了CanCommit ,PreCommit,do   Commit,三个阶段组成事务处理协议,对比2PC它引入超时机制同时在协调者和参与者中都引入了超时机制")]),_._v(" "),a("p",[_._v("3.1 Can Commit : 准备阶段: 协调者向所有参加事务的服务发出询问是否可以执行提交操作,并等待各个节点的相应,")]),_._v(" "),a("p",[_._v("3.2 Pre Commit: 预提交阶段: 完成业务处理和sql预提交并写出操作日志")]),_._v(" "),a("p",[_._v("3.3 do Commit: 提交阶段: 告知所有事务是提交还是回滚")]),_._v(" "),a("p",[_._v("好处:")]),_._v(" "),a("p",[_._v("对比二次提交,三次提交主要解决了单点故障问题,减少了阻塞事件")]),_._v(" "),a("h4",{attrs:{id:"_3-pcc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-pcc"}},[_._v("#")]),_._v(" 3. PCC")]),_._v(" "),a("p",[_._v("PCC: Try - Confirm - Cancel,2PC和3PC都是数据库事务上的处理,而TCC是业务上的处理比如发送手机短信")]),_._v(" "),a("p",[_._v("Try 指的是预留,即资源的预留和锁定.")]),_._v(" "),a("p",[_._v("Confirm 指的是确认操作,这一步其实就是真正的执行了.")]),_._v(" "),a("p",[_._v("Cancel 指的是撤销操作,可以理解为把预留阶段的动作撤销了.")]),_._v(" "),a("p",[_._v("从思想上看PCC和 2PC 差不多，都是先试探性的执行，如果都可以那就真正的执行，如果不行就回滚。")]),_._v(" "),a("p",[_._v("缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。")]),_._v(" "),a("h4",{attrs:{id:"_4-本地消息表"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-本地消息表"}},[_._v("#")]),_._v(" 4.本地消息表")]),_._v(" "),a("p",[_._v("本地消息表就是利用了各个系统本地的事务来实现分布式事务")]),_._v(" "),a("p",[_._v("本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。")]),_._v(" "),a("ol",[a("li",[_._v("在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。")]),_._v(" "),a("li",[_._v("之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。")]),_._v(" "),a("li",[_._v("在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。")])]),_._v(" "),a("p",[_._v("优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。")]),_._v(" "),a("p",[_._v("缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。")]),_._v(" "),a("h4",{attrs:{id:"_5-消息事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-消息事务"}},[_._v("#")]),_._v(" 5.消息事务")]),_._v(" "),a("p",[_._v("有一些第三方的MQ是支持事务消息的,比如RocketMQ,他们支持事务消息的方式也是类似于采用的二阶段提交,但是市面上一些主流的MQ都是不支持事务消息的,比如 RabbitMQ 和 Kafka 都不支持.下面我们来看一下如何通过消息实现事务")]),_._v(" "),a("ol",[a("li",[_._v("首先服务 A 发送一个半事务消息(也称 half 消息)至 MQ 中")]),_._v(" "),a("li",[_._v("如果 half 消息发送成功,MQ 收到这个 half 消息后,会返回一个 success 响应给服务 A.服务 A 接收到 MQ 返回的 success 响应后,开始处理本地的业务逻辑,并提交本地事务")]),_._v(" "),a("li",[_._v("如果服务 A 本地事务提交成功,则会向 MQ 中发送 commit,表示将 half 消息提交,MQ 就会执行第 5 步操作；如果服务 A 本地事务提交失败,则直接回滚本地事务,并向 MQ 中发送 rollback,表示将之前的 half 消息进行回滚,MQ 接收到 rollback 消息后,就会将 half 消息删除")]),_._v(" "),a("li",[_._v("如果 commit,则将 half 消息写入到磁盘")]),_._v(" "),a("li",[_._v("如果 MQ 长时间没有接收到 commit 或者 rollback 消息,那么 MQ 就会在一定时间后尝试调用服务 A 提供的一个接口,通过这个接口来判断 half 消息的状态")]),_._v(" "),a("li",[_._v("服务 B 从 MQ 中消费到对应的消息")]),_._v(" "),a("li",[_._v("服务 B 处理本地业务逻辑，然后提交本地事务")])]),_._v(" "),a("h4",{attrs:{id:"_6-最大努力通知"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-最大努力通知"}},[_._v("#")]),_._v(" 6.最大努力通知")]),_._v(" "),a("p",[_._v("​\t尽最大努力不断重试,比如调用第三方Api进行支付.接口调用后 通过后端定时任务不断调用查询结果Api通过返回结果修改订单状态")])])}),[],!1,null,null,null);v.default=r.exports}}]);